(window.webpackJsonp=window.webpackJsonp||[]).push([[367],{1481:function(a,t,s){"use strict";s.r(t);var _=s(4),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("[TOC]")]),a._v(" "),s("h1",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),s("h1",{attrs:{id:"一、哈希表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、哈希表"}},[a._v("#")]),a._v(" 一、哈希表")]),a._v(" "),s("h2",{attrs:{id:"_1-什么是哈希表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是哈希表"}},[a._v("#")]),a._v(" 1.什么是哈希表")]),a._v(" "),s("p",[a._v("根据设定的哈希函数和处理冲突的方法，将一组关键字映射到一个有限的地址连续的区间上，并以关键字在地址区间中的“像”（索引）作为记录在表中的存储位置，这种表称为"),s("strong",[a._v("哈希表")]),a._v("。")]),a._v(" "),s("p",[a._v("这一映射过程称为散列，所得存储位置称为"),s("strong",[a._v("哈希地址")]),a._v("或散列地址。")]),a._v(" "),s("p",[a._v("对不同的关键字可能得到同一哈希地址，即 key1 ≠ key2 ，而f(key1) = f(key2)，这种现象称为"),s("strong",[a._v("冲突")]),a._v(" 或 哈希碰撞。")]),a._v(" "),s("h2",{attrs:{id:"_2-构造哈希函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-构造哈希函数"}},[a._v("#")]),a._v(" 2.构造哈希函数")]),a._v(" "),s("h3",{attrs:{id:"_2-1-直接定址法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-直接定址法"}},[a._v("#")]),a._v(" 2.1 直接定址法")]),a._v(" "),s("p",[a._v("取关键字或关键字的某个线性函数值为哈希地址。即：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("H(key) = key 或 H(key) = a * key + b  \n其中a和b为常数\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h3",{attrs:{id:"_2-2-数字分析法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-数字分析法"}},[a._v("#")]),a._v(" 2.2 数字分析法")]),a._v(" "),s("p",[a._v("假设关键字是以r为基数的数（如：以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。")]),a._v(" "),s("h3",{attrs:{id:"_2-3-平方取中法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-平方取中法"}},[a._v("#")]),a._v(" 2.3 平方取中法")]),a._v(" "),s("p",[a._v("取关键字平方后的中间几位为哈希地址")]),a._v(" "),s("h3",{attrs:{id:"_2-4-折叠法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-折叠法"}},[a._v("#")]),a._v(" 2.4 折叠法")]),a._v(" "),s("p",[a._v("将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址，这种方法称为折叠法。")]),a._v(" "),s("h2",{attrs:{id:"_2-5-除留余数法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-除留余数法"}},[a._v("#")]),a._v(" 2.5 除留余数法")]),a._v(" "),s("p",[a._v("取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址。即：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("H(key) = key MOD p,    p<=m\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("h3",{attrs:{id:"_2-6-随机数法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-随机数法"}},[a._v("#")]),a._v(" 2.6 随机数法")]),a._v(" "),s("p",[a._v("选择一个随机函数，取关键字的随机函数值为它的哈希地址，即")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("H(key) = random(key)\n其中random为随机函数\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h2",{attrs:{id:"_3-处理冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-处理冲突"}},[a._v("#")]),a._v(" 3.处理冲突")]),a._v(" "),s("p",[a._v("均匀的哈希函数可以减少冲突，但不能避免。")]),a._v(" "),s("p",[a._v("常用的处理冲突的方法有：")]),a._v(" "),s("blockquote",[s("ul",[s("li",[a._v("开放定址法")])])]),a._v(" "),s("h3",{attrs:{id:"_3-1-开放定址法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-开放定址法"}},[a._v("#")]),a._v(" 3.1 开放定址法")]),a._v(" "),s("p",[a._v("H~i~ = ( H(key) + d~i~ ) MOD m        i = 1,2,...,k (k<=m-1)")]),a._v(" "),s("p",[a._v("其中：")]),a._v(" "),s("blockquote",[s("ul",[s("li",[a._v("H(key) 为哈希函数；m为哈希表表长；")]),a._v(" "),s("li",[a._v("d为增量序列，可有下列三种取法：\n"),s("ul",[s("li",[a._v("（1）d~i~ = 1,2,3...,m-1, 称线性探测再散列")]),a._v(" "),s("li",[a._v("（2）d~i~ = 1^2^ , -1^2^ , 2^2^ , -2^2^ , 3^2^ ,...,k^2^ , -k^2^ ,(k<=m/2)，称为二次探测再散列")]),a._v(" "),s("li",[a._v("（3）d~i~ = 伪随机数序列，称伪随机探测再散列")])])])])]),a._v(" "),s("p",[a._v("若由哈希函数得到哈希地址为i ，产生冲突，此时若用线性探测再散列方法处理，则下一个地址为 i+1，若还冲突，则下一个地址为 i+2，直到找到不发生冲突的地址。")]),a._v(" "),s("h3",{attrs:{id:"_3-2-再哈希法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-再哈希法"}},[a._v("#")]),a._v(" 3.2 再哈希法")]),a._v(" "),s("p",[a._v("H~i~ = RH~i~(key)    i=1,2,...,k")]),a._v(" "),s("p",[a._v("RH~i~均是不同的哈希函数，即在同义词产生地址冲突时计算另一哈希函数地址，直到冲突不再发生。")]),a._v(" "),s("p",[a._v("这种方法不易产生聚集，但增加了计算的时间。")]),a._v(" "),s("h3",{attrs:{id:"_3-3-链地址法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-链地址法"}},[a._v("#")]),a._v(" 3.3 链地址法")]),a._v(" "),s("p",[a._v("将所有关键字为同义词的记录存储在同一线性链表中。")]),a._v(" "),s("p",[a._v("假设某哈希函数产生的哈希地址在区间[0,m-1]，则设立一个指针型向量  Chain ChainHash[m]，其每个分量的初始状态都是空指针。凡哈希地址为i的记录都插入到头指针为ChainHash[m]的链表中。")]),a._v(" "),s("p",[a._v("在链表中的插入位置可以在表头或表尾；也可以在中间，以保持同义词在同一线性链表中按关键字有序。")]),a._v(" "),s("h1",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),s("ol",[s("li",[s("a",{attrs:{href:"http://www.ituring.com.cn/article/274866",target:"_blank",rel:"noopener noreferrer"}},[a._v("数据结构与算法分析 (散列)"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("浅谈算法和数据结构: 十一 哈希表"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=r.exports}}]);